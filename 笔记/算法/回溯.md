回溯法采用试错的思想，它尝试分步的解决一个问题，在分布解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答时，它将取消上一步甚至上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案，回溯法通常用最简单的递归方法实现，在反复重复上述的步骤后，出现两个情况：

- 找到一个可能存在的答案
- 在尝试了所有可能的分布方法后，宣布该问题没有答案



剪枝

回溯算法会应用**剪枝**达到加快搜素速度的目的，有些时候，需要做一些预处理工作，比如排序，才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约时间更多。

剪枝是一种技巧，通常需要根据不同的问题场景采用不同的剪枝策略。由于回溯问题本身时间复杂度高，尽量能剪枝就剪枝。

总结
做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。

在画图的过程中思考清楚：

分支如何产生；
题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？
哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？



**总结：子集、组合类问题，关键是用一个 start 参数来控制选择列表！！最后回溯六步走：**
**①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※**
**②根据题意，确立结束条件**
**③找准选择列表(与函数参数相关),与第一步紧密关联※**
**④判断是否需要剪枝**
**⑤作出选择，递归调用，进入下一层**
**⑥撤销选择**



#### 全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

可以简单的画出树形图如上，

```c++
class Solution {
private:
    int numsSize;
    std::vector<int> nums;
    std::vector<int> path;
    std::vector<std::vector<int>> restVecVec;

public:
    void dfs(const int deepth, std::vector<bool> used)
    {
        if (numsSize == deepth) {
            restVecVec.emplace_back(path);
            return;
        }

        for (int i = 0; i < numsSize; i++) {
            if ( used[i] ) {
                continue;
            }

            path.emplace_back(nums[i]);
            used[i] = true;
            dfs(deepth + 1, used);
            used[i] = false;
            path.pop_back();
        }

        return;
    }

    vector<vector<int>> permute(vector<int>& nums) {
        numsSize = nums.size();
        this->nums = nums;
        std::vector<bool> used(numsSize, false);

        dfs(0, used);

        return restVecVec;
    }
};
```



其他解法1：

```c++

class Solution {
public:
    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){
        // 所有数都填完了
        if (first == len) {
            res.emplace_back(output);
            return;
        }
        for (int i = first; i < len; ++i) {
            // 动态维护数组
            swap(output[i], output[first]);
            // 继续递归填下一个数
            backtrack(res, output, first + 1, len);
            // 撤销操作
            swap(output[i], output[first]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int> > res;
        backtrack(res, nums, 0, (int)nums.size());
        return res;
    }
};
```

其他解法2：

这种解法先求出n-1个值的全排列，然后再把另外一个值分别加到这些全排列上，得到n个值的全排列

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ret;
        if (nums.size() == 1) {
            ret.emplace_back(nums);
            return ret;
        }

        vector<int> tmp(nums.begin()+1, nums.end());
        ret = permute(tmp);
        vector<vector<int>> ans;
        for (auto item : ret) {
            item.emplace_back(nums[0]);
            for(int i = 0; i < item.size(); i++) {
                swap(item[i], item.back());
                ans.emplace_back(item);
                swap(item[i], item.back());
            }
        }

        return ans;
    }
};
```



#### 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。



画出树形图

![img](https://pic.leetcode-cn.com/1598091943-hZjibJ-file_1598091940241)

- 以 target = 7 为 根结点 ，创建一个分支的时 做减法 ；

- 每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 candidate 数组的每个元素的值；
- 减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；
- 所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。



剪枝提速
根据上面画树形图的经验，如果 target 减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，我们可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的；
排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。

![img](https://pic.leetcode-cn.com/1598091943-GPoHAJ-file_1598091940246)



```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ret;
        if (candidates.size()==0) return ret;
        
        sort(candidates.begin(), candidates.end());
        vector<int> ans;
        dfs(candidates, 0, candidates.size(), target, ans, ret);

        return ret;
    }

    void dfs(vector<int> &candidates, int begin, int end, int target, vector<int>& ans, vector<vector<int>> &ret) {
        if (target == 0) {
            ret.emplace_back(ans);
            return;
        }

        for (int i = begin; i < end; i++) {
            if (target-candidates[i] < 0) {
                break;
            }
            ans.emplace_back(candidates[i]);
            dfs(candidates, i, end, target-candidates[i], ans, ret);
            ans.pop_back();
        }
    }
};

```



#### 什么时候使用 used 数组，什么时候使用 begin 变量

可能会疑惑什么时候使用 used 数组，什么时候使用 begin 变量。这里为大家简单总结一下：

排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。
注意：具体问题应该具体分析， 理解算法的设计思想 是至关重要的，请不要死记硬背

