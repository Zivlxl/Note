#### 题目描述

我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 `rectangle[i] = [x1, y1, x2, y2]`，其中`（x1，y1）`是矩形 i 左下角的坐标，` (xi1, yi1) `是该矩形 左下角 的坐标，` (xi2, yi2) `是该矩形 右上角 的坐标。

计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。

返回 总面积 。因为答案可能太大，返回$10^9 + 7$的模 。

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png)

```
输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形覆盖了总面积为6的区域。
从(1,1)到(2,2)，绿色矩形和红色矩形重叠。
从(1,0)到(2,3)，三个矩形都重叠。
```



容易知道，多个矩形之间有交叉重叠，问题的关键在于怎么识别出这些重叠区域，并且把这个区域表示出来。首先容易想到把矩形区域切割，最简单的方式是使用连续的单位横坐标，然后对每个矩形切割，加入到对应的横坐标集中，最后只需要得到所有集合大小的和就是矩形的面积。

代码如下：

```C++
unordered_map<int, unorder_set<int>> m;

for (auto rect : rectangles) {
	for (int i = rect[0]; i < rect[2]) {
		unordered_set<int> s;
		if (m.count(i)) s = m[i];
		for (int j = rect[1]; j < rect[3]; j++) s.emplace(j);
	}
}

把m中所有集合的数量相加
```



不过问题在于，用连续的切割方式，对于面积较大的矩形，显然这种数据结构需要考虑内存极限，因此这种方式并不行。

所以我们就需要使用离散化的方式表是切割的矩形。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a604d0c2bed432786c93bcde0998071.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RfX0RvX19JVF9f,size_16,color_FFFFFF,t_70)

这次切割时，不在使用一个单位的横坐标切割，而是看做一条从左到右的扫描线，直到遇见不同与当前横坐标点的横坐标。

模拟切割过程如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/da11672ea0c64efa9fe0e14b511d943a.gif#pic_center)



那么我们如何维护「覆盖的线段长度」呢？这里同样可以使用到离散化的技巧（扫描线就是一种离散化的技巧，将大范围的连续的坐标转化成 2n个离散的坐标）。由于矩形的上下边界也只有 2n个，它们会将 y轴分成 2n+1个部分，中间的 2n-1个部分均为线段，会被矩形覆盖到（最外侧的2个部分为射线，不会被矩形覆盖到），并且每一个线段要么完全被覆盖，要么完全不被覆盖。因此我们可以使用两个长度为 2n-1的数组 seg 和 length，其中 seg[i] 表示第 ii个线段被矩形覆盖的次数，length[i] 表示第 i 个线段的长度。当扫描线遇到一个左边界时，我们就将左边界覆盖到的线段对应的 seg[i] 全部加 11；遇到一个右边界时，我们就将右边界覆盖到的线段对应的seg[i] 全部减 11。在处理掉一批横坐标相同的左右边界后，seg[i] 如果大于 00，说明它被覆盖，我们累加所有的 length[i]，即可得到「覆盖的线段长度」。



```c++
class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        vector<int> axixY;
        
        for (auto rectangle : rectangles) {
            axixY.emplace_back(rectangle[1]);
            axixY.emplace_back(rectangle[3]);
        }

        sort(axixY.begin(), axixY.end());
        axixY.erase(unique(axixY.begin(), axixY.end()), axixY.end());

        vector<tuple<int, int, int>> axixX;
        for (int i = 0; i < rectangles.size(); i++) {
            axixX.emplace_back(rectangles[i][0], i, 1);
            axixX.emplace_back(rectangles[i][2], i, -1);
        }
        sort(axixX.begin(), axixX.end());
        vector<int> seg(axixY.size() - 1);

        long long ret = 0;

        for (int i = 0; i < axixX.size(); i++) {
            int j = i;

            while (j < axixX.size() - 1 && get<0>(axixX[i]) == get<0>(axixX[j + 1])) {
                j++;
            }

            if (j + 1 == axixX.size()) {
                break;
            }

            for (int k = i; k <= j; k++) {
                auto && [_, idx, dif] = axixX[k];
                int down_y = rectangles[idx][1];
                int up_y = rectangles[idx][3];
                for (int l = 0; l < axixY.size() - 1; l++) {
                    if (down_y <= axixY[l] && up_y >= axixY[l+1]) {
                        seg[l] += dif;
                    }
                }
            }

            int cover = 0;
            for (int k = 0; k < axixY.size() - 1; k++) {
                if (seg[k] > 0) {
                    cover += (axixY[k+1] - axixY[k]);
                }
            }

            ret += static_cast<long long>(cover) * (get<0>(axixX[j+1]) - get<0>(axixX[j]));
            i = j;
        }

        return ret % static_cast<int>(1e9 + 7);

    }
};
```



在上面的代码中，我们找线段的时候，需要和每一个线段进行比对，判断线段在不在矩阵中，这显然增加了时间复杂度，为此我们可以维护一种线段树的数据结构，这样我们寻找线段的操作的复杂度就会降为$logn$，代码如下：

```c++
struct Segtree {
    int cover;
    int length;
    int max_length;
};

class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        int n = rectangles.size();
        for (const auto& rect: rectangles) {
            // 下边界
            hbound.push_back(rect[1]);
            // 上边界
            hbound.push_back(rect[3]);
        }
        sort(hbound.begin(), hbound.end());
        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());
        int m = hbound.size();
        // 线段树有 m-1 个叶子节点，对应着 m-1 个会被完整覆盖的线段，需要开辟 ~4m 大小的空间
        tree.resize(m * 4 + 1);
        init(1, 1, m - 1);

        vector<tuple<int, int, int>> sweep;
        for (int i = 0; i < n; ++i) {
            // 左边界
            sweep.emplace_back(rectangles[i][0], i, 1);
            // 右边界
            sweep.emplace_back(rectangles[i][2], i, -1);
        }
        sort(sweep.begin(), sweep.end());

        long long ans = 0;
        for (int i = 0; i < sweep.size(); ++i) {
            int j = i;
            while (j + 1 < sweep.size() && get<0>(sweep[i]) == get<0>(sweep[j + 1])) {
                ++j;
            }
            if (j + 1 == sweep.size()) {
                break;
            }
            // 一次性地处理掉一批横坐标相同的左右边界
            for (int k = i; k <= j; ++k) {
                auto&& [_, idx, diff] = sweep[k];
                // 使用二分查找得到完整覆盖的线段的编号范围
                int left = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][1]) - hbound.begin() + 1;
                int right = lower_bound(hbound.begin(), hbound.end(), rectangles[idx][3]) - hbound.begin();
                update(1, 1, m - 1, left, right, diff);
            }
            ans += static_cast<long long>(tree[1].length) * (get<0>(sweep[j + 1]) - get<0>(sweep[j]));
            i = j;
        }
        return ans % static_cast<int>(1e9 + 7);
    }

    void init(int idx, int l, int r) {
        tree[idx].cover = tree[idx].length = 0;
        if (l == r) {
            tree[idx].max_length = hbound[l] - hbound[l - 1];
            return;
        }
        int mid = (l + r) / 2;
        init(idx * 2, l, mid);
        init(idx * 2 + 1, mid + 1, r);
        tree[idx].max_length = tree[idx * 2].max_length + tree[idx * 2 + 1].max_length;
    }

    void update(int idx, int l, int r, int ul, int ur, int diff) {
        if (l > ur || r < ul) {
            return;
        }
        if (ul <= l && r <= ur) {
            tree[idx].cover += diff;
            pushup(idx, l, r);
            return;
        }
        int mid = (l + r) / 2;
        update(idx * 2, l, mid, ul, ur, diff);
        update(idx * 2 + 1, mid + 1, r, ul, ur, diff);
        pushup(idx, l, r);
    }

    void pushup(int idx, int l, int r) {
        if (tree[idx].cover > 0) {
            tree[idx].length = tree[idx].max_length;
        }
        else if (l == r) {
            tree[idx].length = 0;
        }
        else {
            tree[idx].length = tree[idx * 2].length + tree[idx * 2 + 1].length;
        }
    }

private:
    vector<Segtree> tree;
    vector<int> hbound;
};
```

