#### 题目描述

给你一个字符串` s `，请你统计并返回这个字符串中** 回文子串 **的数目。

**回文字符串 **是正着读和倒过来读一样的字符串。

**子字符串 **是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```



#### 动态规划法

- 对于字符串中的每一个字符来说，其都是一个回文字符串

- 对于包含两个字符的字符串，只要这两个字符相同，该字符串就是回文字符串

- 对于数量大于2的字符串，只有当首尾两个字符相同且中间的字符子串为回文串时，该字符串才为回文字符串

  状态转移方程
  $$
  dp[i][i] = true
  $$

  $$
  dp[i][i+1] = true\quad when str[i]==str[i+1]
  $$

  $$
  dp[i][i+j] = true\quad when str[i]==str[i+j]\&\&dp[i+1][i+j-1]==true\quad j>1
  $$



```c++
class Solution {
public:
    int countSubstrings(string s) {
        int ret = s.size();
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) {
            dp[i][i] = true;
        }
        for (int i = 1; i < s.size(); i++) {
            for (int j = 0; j < s.size(); j++) {
                if (j+i>=s.size()) break;
                bool flag = i==1?true:dp[j+1][j+i-1];
                if (flag && s[j] == s[j+i]) {
                    dp[j][j+i] = true;
                    ret++;
                } 
            }
        }

        return ret;
    }
};
```



#### 中心拓展法

该方法的思路就是找到一个回文子串（最简单的一个或两个字符），从该回文子串开始，向左右两端扩展，如果两端的字符相同，则加上首尾该子串还是回文字符串，知道找不到依次子串为基础的更大的回文子串。然后从下一个基本回文子串开始，继续搜索。

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s[l] == s[r]) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};
```



#### Manacher算法