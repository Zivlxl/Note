#### 题目描述

给你一个整数` n `，返回 和为` n `的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。



#### 动态规划

从1开始算起，算到n结束

状态转移方程如下：
$$
dp[i] = 1+mindp[i-j^2]\quad for\quad j^2<i
$$

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> v(n+1, 0);
        for (int i = 1; i <= n; i++) {
            int minX = INT_MAX;
            for (int j = 1; j*j <= i; j++) {
                minX = min(minX, v[i-j*j]);
            }
            v[i] = minX+1;
        }
        return v[n];
    }
};
```



也可以使用回溯法求解，不过会超出时间限制



#### 四平方定理

运用一个数学定理可以更方便的解决这道题。

四平方定理：任意一个正整数都可以被表示为至多四个正整数的平方和。同时只有$n\neq4^k*(8m+7)$时，n最多能被表示为3个正整数的平方和，也就是说$n=4^k*(8m+7)$时，n只能被表示为四个正整数的和。

其他三种情况：

- 当答案为1时，n为完全平方数
- 答案为2时，只要枚举所有$j^2 < n$，判断$n-j^2$是否为完全平方数即可
- 排除法，不是以上几种情况，则答案为3

```c++
class Solution {
public:
    // 判断是否为完全平方数
    bool isPerfectSquare(int x) {
        int y = sqrt(x);
        return y * y == x;
    }

    // 判断是否能表示为 4^k*(8m+7)
    bool checkAnswer4(int x) {
        while (x % 4 == 0) {
            x /= 4;
        }
        return x % 8 == 7;
    }

    int numSquares(int n) {
        if (isPerfectSquare(n)) {
            return 1;
        }
        if (checkAnswer4(n)) {
            return 4;
        }
        for (int i = 1; i * i <= n; i++) {
            int j = n - i * i;
            if (isPerfectSquare(j)) {
                return 2;
            }
        }
        return 3;
    }
};
```

