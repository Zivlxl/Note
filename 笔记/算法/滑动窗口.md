解决符合某种条件的最长（最小）子串问题时，使用滑动窗口的方法



暴力解法时间复杂度较高，会达到 $O(n^2)$，故而采取滑动窗口的方法降低时间复杂度
定义一个 map 数据结构存储$ (k, v)$，其中$ key$ 值为字符，$value $值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
我们定义不重复子串的开始位置为 `start`，结束位置为 `end`
随着 `end` 不断遍历向后，会遇到与 `[start, end] `区间内字符相同的情况，此时将字符作为 $key$ 值，获取其 $value $值，并更新 `start`，此时` [start, end]` 区间内不存在重复字符
无论是否更新` start`，都会更新其 map 数据结构和结果 ans。
时间复杂度：$O(n)$

在c++中，`unordered_set`和`unordered_map`一样也是使用hash table实现的，在`unordered_set`中，key作为hash表的索引，而其值被设置成1，因此使用`unordered_set`解决上面问题是最理想的数据结构



ex：求无重复字符的最长字串

```c++
/*
 * @lc app=leetcode.cn id=3 lang=cpp
 *
 * [3] 无重复字符的最长子串
 */

// @lc code=start
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() == 0) {return 0;}
        std::unordered_set<char> set;
        int maxSize = 0;
        int start = 0;
        for (int end = 0; i < s.size(); end++)
        {
            while (set.find(s[end]) != set.end())
            {
                set.erase(s[start]);
                start++;
            }

            maxSize = max(maxSize, end-start+1);
            set.insert(s[end]);
        }

        return maxSize;
        
    }
};
```

