#### 题目描述

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个**相同种类**的任务之间必须有长度为整数` n `的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的**最短时间 **。

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。
```



#### 解答

容易知道，无论n是多少，这个最短时间的**下限**一定是tasks的大小。

解决这个问题，首先需要安排最大数量的一类任务A，这些任务一定需要错开n个单位时间，然后考虑把其他类型的任务插入到最大数量任务中间。因此我们要考虑具有相同最大数量的任务的类型（即为任务A、B、C的数量都为m，m最大）数量cnt，这cnt个数量必须依次交替进行才能保证最小时间，而对于其它小于最大数量的类型，只需要把他们插入运行一轮cnt个最大类型之后，这样不仅不会影响原来的结构，同时没有新的空闲时间。这样我们只需要考虑有没有空闲的时间即可，有空闲的时间下，说明没有把空隙插满（cnt的数量小于n），此时最后一个A的时间即为最短时间；当空插满所有空隙时，最短时间就是tasks的大小。

因此关键就是求到cnt，根据cnt求出最后一个A（）的运行时间，即为`cnt+(n+1)*(m-1)`，最短事件就是`max(len, cnt+(n+1)*(m-1))`

```c++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        int len = tasks.size();
        vector<int> v1(26, 0);
        for (auto c : tasks) {
            v1[c-'A']++;
        }
        sort(v1.rbegin(), v1.rend());

        int cnt=1;
        while(cnt<v1.size()&&v1[cnt]==v1[0]) cnt++;
        return max(len,cnt+(n+1)*(v1[0]-1) );

    }
};
```



#### 官方解答

参考「桶思想」，详细说明各种情况
建立大小为 n+1 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 n=2，A 任务个数 6 个，我们建立 6 桶子，每个容量为 3：
我们可以把一个桶子看作一轮任务



先从最简单的情况看起，现在就算没有其他任务，我们完成任务 A 所需的时间应该是 (6-1)*3+1=16，因为最后一个桶子，不存在等待时间。


接下来我们添加些其他任务


可以看到 C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；而 B 和 A 数量相同，这会导致最后一个桶子中，我们需要多执行一次 B 任务，现在我们需要的时间是 (6-1)*3+2=17

前面两种情况，总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数

当冷却时间短，任务种类很多时


比如上图，我们刚好排满了任务，此时所需时间还是 17，如果现在我还要执行两次任务 F，该怎么安排呢？

此时我们可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况：
插入前：ABC | ABC | ABD | ABD | ABD | AB
插入后：ABCF | ABCF | ABD | ABD | ABD | AB
我们在第一个、第二个桶子里插入了任务F，不难发现无论再继续插入多少任务，我们都可以类似处理，而且新插入元素肯定满足冷却要求
继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。
也就是说，我们执行任务所需的时间，就是任务的数量

这样剩下就很好处理了，我们只需要算两个数：

记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X，计算 NUM1=(N-1)*(n+1)+x
NUM2=tasks.size()
输出其中较大值即可
因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是 NUM2>=NUM1

```c++
int leastInterval(vector<char>& tasks, int n) {
        int len=tasks.size();
        vector<int> vec(26);
        for(char c:tasks) ++vec[c-'A'];
        sort(vec.begin(),vec.end(),[](int& x,int&y){return x>y;});
        int cnt=1;
        while(cnt<vec.size()&&vec[cnt]==vec[0]) cnt++;
        return max(len,cnt+(n+1)*(vec[0]-1) );
    }
```


时间复杂度 O(nlogn)，空间复杂度 O(1)

链接：https://leetcode.cn/problems/task-scheduler/solution/tong-zi-by-popopop/