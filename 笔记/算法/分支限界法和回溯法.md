### 分支限界法（Branch and Bound）

#### 基本思想

分支限界法是以广度优先或者最小耗费（最大效益）优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点只能成为一次扩展结点，成为扩展结点后，一次性产生所有的子结点，在这些子结点中，导致不可行解或者非最优解的儿子结点被舍弃，而其他结点加入到活结点列表中。之后，从活结点表中选取下一个结点成为当前扩展结点，重复上述过程，直至找到所需的解或者活结点表为空。

#### 常见两种分支限界法

1. 队列式（FIFO）分支限界法（装载问题）

   按照队列先进先出（FIFO）原则选取下一个结点为扩展结点

2. 优先队列分支限界法

   按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点（）

#### 求解步骤

1. 定义解空间
2. 确定解空间树结构
3. 按照BFS方式搜索解空间树：
   1. 每个活结点只有一个机会成为扩展结点
   2. 由扩展结点生成一步可达的新节点
   3. 删除新节点中不可能得到最优解的结点（限界策略，使用限界函数）
   4. 将剩余结点添加到活结点列表中
   5. 在活结点表中取出每个结点当作扩展结点（分支策略）
   6. 直至活结点为空或者求得最优解

约束函数：问题定义时的约束条件

目标函数：问题要求解的目标函数，分支限界法中需要一个关于该函数的上下界，方便剪枝

限界函数：用于记录当前结点之下可以得到的最优解，如果超出上下界，放弃该结点；还用于活结点表中结点排序，限界函数值最优的在第一位，优先扩展遍历

#### 装载问题

[装载问题-分支限界法(队列式分支限界法,优先队列式分支限界法) - 灰信网（软件开发博客聚合） (freesion.com)](https://www.freesion.com/article/9394920015/)

##### 问题描述

有n个集装箱要装上2艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且
$$
\sum_{i=1}^{n}{w_i}<c_1+c_2
$$
是否有一个合理的装载方案,可将这n个集装箱装上这2艘轮船?如果有，找出一种装载方案。

已证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。

1. 首先将第一艘轮船尽可能装满；
2. 将剩余的集装箱装上第二艘轮船。

  将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于以下特殊的0-1背包问题。

##### 队列式分支限界法

- 解装载问题的队列式分支限界法仅求出所要求的最优值，稍后进一步构造最优解。
- 首先检测当前扩展结点的左儿子结点是否为可行结点。如果是，则将其加入到活结点队列Q中。
- 然后，将其右儿子结点加入到活结点队列中(右儿子结点一定是可行结点)。2个儿子结点都产生后，当前扩展结点被舍弃。
- 活结点队列中，队首元素被取出作为当前扩展结点。
- 活结点队列已空，算法终止。

注：叶子结点不会被扩展，因此不用加入到活结点队列当中，此时，只需要检查该叶节点表示的最优解是否优于当前最优解，并实时更新当前最优解。同层尾部标记：-1。当取出的元素是-1时，判断当前队列是否为空，如果队列不空，则将尾部标记 -1加入到活节点队列中，代表算法开始处理下一层活节点，即：代表算法开始处理 下一个物品的装载问题（每一层i开始处理第i个物品的装载）。

##### 代码

```
emplate<class Type>
Type MaxLoading(Type w[], Type c, int n)
{ //初始化
Queue<Type>Q; //  活结点队列
Q.Add(-1);  // 同层结点尾部标志
int i=1; //当前扩展结点所处的层
Type Ew=0; //扩展结点处相应的载重量
         bestw=0;
//搜索子集空间树
while (true) {
      // 检查左儿子结点
      if (Ew + w[i] <= c1) // x[i] = 1，Ew存储当前扩展结点相应的载重量
      EnQueue(Q, Ew + w[i], bestw, i, n); //将活结点加入到活结点队列Q中
      // 右儿子结点总是可行的，将其加入到Q中
      EnQueue(Q, Ew, bestw, i, n); // x[i] = 0
      Q.Delete(Ew);     // 取下一扩展结点
      if (Ew == -1) {      // 同层结点尾部
         if (Q.IsEmpty( )) return bestw;
         Q.Add(-1);        // 同层结点尾部标志
         Q.Delete(Ew);  // 取下一扩展结点
         i++;}                 // 进入下一层     
        }
  }

```

##### 算法改进

结点的左子树代表将此集装箱装上船，右子树表示不装上船。当Ew+r<bestw时，可知其右子树不可能包含最优解，剪去其右子树。另外，为了确保右子树成功剪枝，应该在算法每一次进入左子树的时候更新bestw的值。

```
while (true) {
      // 检查左儿子结点
      // wt=Ew + w[i];   // 左儿子结点的重量
      if (wt<= c) {     // 可行结点
         if (wt > bestw) bestw = wt;   //提前更新bestW,注意更新条件
         // 加入活结点队列
         if (i <= n) Q.Add(wt);
  	 }
     // 检查右儿子结点
      if (Ew + r > bestw && i <= n)   //右儿子剪枝
          Q.Add(Ew);     // 可能含最优解
      Q.Delete(Ew);     // 取下一扩展结点
      if (Ew == -1) {      // 同层结点尾部
         if (Q.IsEmpty()) return bestw;
         Q.Add(-1);        // 同层结点尾部标志
         Q.Delete(Ew);  // 取下一扩展结点
         i++;
         r-=w[i];}                 // 进入下一层      
 	}  
 }

```

##### 优先队列分支限界法

- 解装载问题的优先队列式分支限界法用最大优先队列存储活结点表。
- 活结点x在优先队列中的优先级定义为从根结点到结点x的路径所相应的载重量Ew(即：当前扩展结点船的载重量Ew)再加上剩余集装箱的重量r之和（即：将上界Ew+r定义为结点优先级）。
- 优先队列中优先级最大的活结点成为下一个扩展结点。
- 子集树中叶结点所相应的载重量与其优先级（上界值）相同，即：该叶子结点的上界值等于当前叶子结点处船的重量Ew。
- 在优先队列式分支限界法中，一旦有一个叶结点成为当前扩展结点，则可以断言该叶结点所相应的解即为最优解。此时可终止算法。

##### 求最优解

- 在优先队列的每一个活结点中，保存从解空间树的根结点到该活结点的路径，在算法确定了达到最优值的叶结点时，就在该叶结点处同时得到相应的最优解。
- 在算法的搜索进程中，保存当前已构造出的部分解空间树，这样在算法确定了达到最优值的叶结点时，可以在解空间树中从该叶结点开始向根结点回溯，构造出相应的最优解。

#### 布线问题

[算法详解之分支限界法的具体实现_C 语言_脚本之家 (jb51.net)](https://www.jb51.net/article/46890.htm)

##### 问题描述

布线问题：印刷电路板将布线区域划分成n×m个方格阵列，要求确定连接方格阵列中的方格a的中点到方格b的中点的最短布线方案。在布线时，电路只能沿直线或直角布线，为了避免线路相交，已布了线的方格做了封锁标记，其他线路不允许穿过被封锁的方格。如下图所示：

![image-20220302223753610](C:\Users\ziv\AppData\Roaming\Typora\typora-user-images\image-20220302223753610.png)

##### 算法思路

布线问题的解空间是一个图，则从起始位置a开始将它作为第一个扩展结点。与该扩展结点相邻并可达的方格成为可行结点被加入到活结点队列中，并且将这些方格标记为1，即从起始方格a到这些方格的距离为1。接着，从活结点队列中取出队首结点作为下一个扩展结点，并将与当前扩展结点相邻且未标记过的方格标记为2，并存入活结点队列。这个过程一直继续到算法搜索到目标方格b或活结点队列为空时为止。

在实现上述算法时，

1.  定义一个表示电路板上方格位置的类Position。

   ![](https://img.jbzj.com/file_images/article/201402/2014217144937270.png)

   它的2个成员row和col分别表示方格所在的行和列。在方格处，布线可沿右、下、左、上4个方向进行。沿这4个方向的移动分别记为0，1，2，3。下表中，offset[i].row和offset[i].col(i= 0,1,2,3)分别给出沿这4个方向前进1步相对于当前方格的相对位移。

2. 用二维数组grid表示所给的方格阵列。

   初始时，grid[i][j] = 0, 表示该方格允许布线，而grid[i][j] = 1表示该方格被封锁，不允许布线。

![2014217145037594.png](https://img.jbzj.com/file_images/article/201402/2014217145037594.png)

回溯法处理该问题比较低效。因为回溯法的搜索时依据深度优先的原则，如果把上下左右四个方向规定一个固定的优先顺序去进行搜索，搜索会沿着某个路径一直进行下去直到碰壁才会换到另一个子路径，但是开始时根本无法判断正确的路径方向是什么，造成了盲目的搜索。另外，即使搜索到了一条从a到b的路径，根本也无法保证他就是所有路径中最短的，这就要求必须把整个区域的所有路径逐一搜索后才能得到最优解。

### 回溯法

[(81条消息) [回溯算法\] 五大常用算法之回溯法_fei的专栏-CSDN博客_回溯算法](https://blog.csdn.net/weiyuefei/article/details/79316653)

#### 基本思想

把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。

- 针对所给问题，定义问题的解空间；
- 确定易于搜索的解空间结构；
- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

常见剪枝函数

- 约束函数：在扩展结点处减去不满足约束的子树
- 限界函数：减去得不到最优解的子树

#### 详细描述

​    回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。

​    回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。

​    问题的关键在于如何定义问题的解空间，转化成树（即解空间树）。解空间树分为两种：子集树和排列树。两种在算法结构和思路上大体相同。

#### 递归回溯和迭代回溯

回溯法对解空间作深度优先搜索，因此，在一般情况下用递归方法实现回溯法。

```
void backtrack (int t)

{

    if (t > n) {

       // 到达叶子结点，将结果输出

       output (x);

    }

    else {

       // 遍历结点t的所有子结点

       for (int i = f(n,t); i <= g(n,t); i ++ ) {

           x[t] = h[i];

           // 如果不满足剪枝条件，则继续遍历

           if (constraint (t) && bound (t)) 

              backtrack (t + 1);

       }

    }

}
```

采用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。

```
// 针对N叉树的迭代回溯方法

void iterativeBacktrack ()

{

    int t = 1;

    while (t > 0) {

       if (f(n,t) <= g(n,t)) {

           //  遍历结点t的所有子结点

           for (int i = f(n,t); i <= g(n,t); i ++) {

              x[t] = h(i);

              // 剪枝

              if (constraint(t) && bound(t)) {

                  // 找到问题的解，输出结果

                  if (solution(t)) {

                     output(x);

                  }

                  else // 未找到，向更深层次遍历

                     t ++;

              }

           }

       }

       else {

           t--;

       }

    }

}
```

#### 子集树和排列树

子集树（遍历子集树需O(2^n)计算时间）

![img](https://pic002.cnblogs.com/images/2010/153357/2010102222020822.jpg)

排列树（遍历排列树需要O(n!)计算时间）

![img](https://pic002.cnblogs.com/images/2010/153357/2010102222034229.jpg)

#### 装载问题

```
void backtrack (int i)

{

    // 搜索第i层结点

    if (i > n)  // 到达叶结点

       更新最优解bestx,bestw;return;

    r -= w[i];

    if (cw + w[i] <= c) {

       // 搜索左子树

       x[i] = 1;

       cw += w[i];

       backtrack (i + 1);

       cw -= w[i];     

    }

    if (cw + r > bestw)  {

       x[i] = 0;  // 搜索右子树

       backtrack(i + 1);     

    }

    r += w[i];

}
```

变量解释：

r: 剩余重量

w: 各个集装箱重

cw:当前总重量

x: 每个集装箱是否被选取标志

bestx: 最佳选取方案

bestw: 最优载重量

### 分支限界法和回溯法的区别

两者很类似，很容易混淆，但有如下显著的区别可区分两者：

- 求解目标不同

回溯法的求解目标一般是找出解空间树中满足条件的所有解。

分支限界法则是尽快找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。

- 搜索方式不同

回溯法：深度优先遍历结点搜索解空间树。

分支限界法：广度优先或最小耗费优先搜索解空间树。

- 存储空间不同

分支限界法由于加入了活结点表，所以存储空间比回溯法大得多。因此当内存容量有限时，回溯法的成功率要大一些。

- 扩展结点的方式不同

分支限界法中，每个活结点只有一次机会变成扩展结点，一旦成为扩展结点便一次性生成其所有子结点。

区别小结：回溯法空间效率更高，分支限界法由于只需要求到一个解，所以往往更“快”。