#### C++流

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200205123355748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70)



#### 文件流

若要使用文件流，需要用到C++中的标准库`include<fstream>`，它定义了三种数据类型：

- ofstream：该数据类型表示输出文件流，用于创建文件并向文件写入信息。
- ifstream：该数据类型表示输入文件流，用于从文件读取信息。
- fstream：该数据类型表示输入和输出文件流，且同时具有ofstream和ifstream两种功能。



##### 定义文件流

```cpp
#include <fstream>

using namespace std;	// 声明命名空间

int main(void) {
	// 声明输出文件流，用于创建文件并向文件写入信息。
	ofstream outFile;

	// 声明输入文件流，用于从文件读取信息。
	ifstream inFIle;

	// 声明输入和输出文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。
	fstream stream;
	
	return 0；
}

```



##### 打开文件

`void open(const char * filename, mode, ...)`

文件的打开方式如下：

|  模式标志   | 描述                                                  |
| :---------: | ----------------------------------------------------- |
|   ios::in   | 读方式打开文件                                        |
|  ios::out   | 写方式打开文件                                        |
| ios::trunc  | 如果此文件已经存在, 就会打开文件之前把文件长度截断为0 |
|  ios::app   | 尾部最加方式(在尾部写入)                              |
|  ios::ate   | 文件打开后, 定位到文件尾                              |
| ios::binary | 二进制方式(默认是文本方式)                            |

以上的打开方式，可以使用位操作|组合起来使用

`is_open()`判断文件是否打开成功



##### 关闭文件

`close()` 打开文件后一定要关闭



##### 读写文件

使用流运算符<<和>>



##### 读取文件中的一行数据

使用`getline(infile, line)`

```cpp
#include<iostream>
#include<fstream>

int main(){
char line[1024] = {0};
ifstream infile;
infile.open("test.txt");
infile.getline(line, 1024);

cout << line << endl;

infile.close();
return 0;
}
```



#### istream和ostream中的方法

#### istream

`istream& gcount()` 统计输入字符数

`istream& get(char& c)`获取一个字符

`istream& get(char *s, streamsize n)`

`istream& getline(char*s, streamsize n, char delim)`读取一行，直至读取了n个字符或者遇见delim。

`istream& ignore(streamsize n = 1, int delim = EOF)` 从输入流中读取字符，直到丢弃了n个字符或者遇见了delim。

`istream& read(char *s, streamsize n)`读取n个字符

`streampos tellg()`，返回当前位置到输入流起点的距离

`istream& seekg(stream pos)` `seekg()`是对输入流的操作 g是get缩写

file.seekp(20L, ios::beg);

**第一个实参是一个 long 类型的整数，表示文件中的偏移量**。这就是想要移动到的字节数。在该示例中，使用的是 20L（请记住，L 字符可以强制编译器将该数字视为一个 long 类型的整数）。该语句可以将文件的写入位置移动到编号为 20 的字节（所有编号从 0 开始，因此编号为 20 的字节实际上是第 21 个字节）。

**第二个实参称为模式标志，它指定从哪里计算偏移量**。标志 ios::beg 表示偏移量是从文件开头算起的。也可以修改该参数，从文件末尾或文件中的当前位置计算偏移量。下面列出了所有 3 种随机访问模式的标志。

文件定位标志模式标志 描 述
ios::beg 从文件头开始计算偏移量
ios::end 从文件末尾开始计算偏移量
ios::cur 从当前位置开始计算偏移量

```cpp
// read a file into memory
#include <iostream>     // std::cout
#include <fstream>      // std::ifstream

int main () {

  std::ifstream is ("test.txt", std::ifstream::binary);
  if (is) {
    // get length of file:
    is.seekg (0, is.end);
    int length = is.tellg();
    is.seekg (0, is.beg);

    char * buffer = new char [length];

    std::cout << "Reading " << length << " characters... ";
    // read data as a block:
    is.read (buffer,length);

    if (is)
      std::cout << "all characters read successfully.";
    else
      std::cout << "error: only " << is.gcount() << " could be read";
    is.close();

    // ...buffer contains the entire file...

    delete[] buffer;
  }
  return 0;
}
```



##### ostream

`ostream& flush()`刷新输出流缓冲区

`seekp`同上

`ostream& write (const char*s, streamsize n)` 写入n个字符

`tellp`同上

`ostream& put(char c)`输出一个字符到流

```cpp
// position in output stream
#include <fstream>      // std::ofstream

int main () {

  std::ofstream outfile;
  outfile.open ("test.txt");

  outfile.write ("This is an apple",16);
  long pos = outfile.tellp();
  outfile.seekp (pos-7);
  outfile.write (" sam",4);

  outfile.close();

  return 0;
}
```

