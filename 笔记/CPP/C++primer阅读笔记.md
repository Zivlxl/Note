- 想要输出十进制（默认）、八进制和十六进制的数字时，分别使用dec、oct和hex，这些都位于标准库iostream中。

```c++
cout << oct;
cout << 42；
//52
cout << hex;
cout << 42 <<endl;
//2a
```



- cctype软件包

  ```c++
  #include<cctype>
  ```

  | 函数名称   |                                                    |
  | ---------- | -------------------------------------------------- |
  | isalpha()  | 参数是否是字母                                     |
  | isalnum()  | 参数是否是字母或数字                               |
  | isdigit()  | 参数是否为数字                                     |
  | islower()  | 是否是小写字母                                     |
  | iscntrl()  | 是否是控制字符                                     |
  | ispunct()  | 是否是标点符号                                     |
  | issupper() | 是否为大写字母                                     |
  | isspace()  | 是否为标准空白字符，如空格、进制、换行符、制表符等 |
  | tolower()  | 返回小写字母                                       |
  | toupper()  | 返回大写字母                                       |



- 函数指针

  ```c++
  //声明函数指针
  double *(*pf) (int); //返回double指针的函数，包含一个int型参数
  
  //函数指针调用，下面两种方式都可以
  pf()；
  (*pf)();
  
  //声明函数指针数组
  double *(*pf[3]) (int); //声明了一个3个元素的函数指针数组
  
  //函数指针数组调用
  (*pf)[1];
  
  //使用typedef或者auto关键字简化
  
  //定义一个很复杂的函数，把它赋值给一个函数指针，我们要写很长的函数指针声明，使用auto 关键字
  const int *func(int, string, double);
  auto pf = func;
  
  typedef int *(p_fun)(int, string, double);
  p_fun p1 = func;
  ```



- 内联函数

  内联函数是C++的增强特性之一，用来降低程序的运行时间。当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。

  ​     值得注意的是，内联函数仅仅是对编译器的内联建议，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。

  - 为什么使用内联函数？

    常规函数调用会使用栈，函数的调用和返回会有一定的时间开销，所以 对于一些功能比较小的函数，使用内联函数。

  - 什么时候使用内联函数？

    当程序设计需要时，每个函数都可以声明为inline。下面列举一些有用的建议：

    1. 当对程序执行性能有要求时，那么就使用内联函数吧。
    2. 当你想宏定义一个函数时，那就果断使用内联函数吧。
    3. 在类内部定义的函数会默认声明为inline函数，这有利于 类实现细节的隐藏。

  - 关键点
    1.  内联声明只是一种对编译器的建议，编译器是否采用内联措施由编译器自己来决定。甚至在汇编阶段或链接阶段，一些没有inline声明的函数编译器也会将它内联展开。
    2. 编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难。
    3. 所有中类中定义的函数都默认声明为inline函数，所有我们不用显示地去声明inline。
    4. 虚函数不允许内联。
    5. 虽然说模板函数放中头文件中，但它们不一定是内联的。（不是说定义在头文件中的函数都是内联函数）。



- decltype关键字

  编写模板函数时，遇到下面情况，并非总是能够知道应在声明中使用哪种类型

  ```c++
  template<class T1, class T2>
  void ft(T1 t1, T2 t2) {
  	...
  	?type? xpy = t1 + t2;
  	...
  }
  ```

  这种情况下，C++提供了一个关键字`decltype`

  ```c++
  decltype(t1+t2) xpy; //make xpy the same type  with t1+t2
  xpy = t1 + t2
  ```

  `decltype`的使用，为确定类型，编译器必须遍历一个核对表，假设有如下声明：`decltype(expression) var;`

  第一步，如果`expression`是一个没有用括号括起来的标识符，则`var`的类型与该标识符的类型相同，包括`const`限定符；

  ```c++
  const double *pd;
  decltype(pd) v; //v is type const double *
  ```

  第二步，如果`expression`是一个函数调用，则`var`的类型与函数的返回类型相同；

  ```c++
  long indeed(int);
  decltype(indeed(3)) m; //m is type long
  ```

  第三步，如果`expression`是一个左值，且用括号括起来，则`var`为指向其类型的引用；

  ```c++
  double xx = 4.4;
  decltype((xx)) r; //r is type double &
  decltype(xx) r1; //r1 is type double
  ```

  第四步，如果前面的条件都不满足，则`var`的类型与`expression`的类型相同。

  ```c++
  int j = 3;
  int &k = j;
  int &n = j;
  
  decltype(j+5) i1; //i1 is type int
  decltype(100L) i2; //i2 is type long
  decltype(k+n) i3; //i3 is type int
  ```

  虽然`k`和`n`都是引用，但是表达式`k+n`不是引用，它是两个`int`的和，因此类型是`int`。

  另外，如果需要多次声明，可结合使用`typedef`和`decltype`。

  ```c++
  template<class T1, class T2>
  void ft(T1 t1, T2 t2) {
  	typedef decltype(t1+t2) xytype;
  	xytype xpy = t1 + t2;
  	xytype arr[10];
  	xytype &rxy = arr[2]; 
  }
  ```



- 左值和右值

  - 可以取地址的，有名字的，非临时的就是左值
  - 不能取地址的，没有名字的，临时的就是右值

  可见**立即数**、**函数返回值**等都是右值；而**非匿名对象（包括变量）**、**函数返回的引用**、**const对象**等都是左值。

  右值引用是C++ 11新增的特性，所以C++ 98的引用为左值引用。右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。

  ```c++
  int &&var = 10; //true 右值引用 
  int &var = 10; //false 左值引用
  ```

  右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。
  转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。
  通过转移语义，临时对象中的资源能够转移其它的对象里。
  在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。

  | 引用类型       | 非常量左值 | 常量左值 | 非常量右值 | 常量右值 | 使用场景                   |
  | -------------- | ---------- | -------- | ---------- | -------- | -------------------------- |
  | 非常量左值引用 | Y          | N        | N          | N        | 无                         |
  | 常量左值引用   | Y          | Y        | Y          | Y        | 常用语类中构建拷贝构造函数 |
  | 非常量右值引用 | N          | N        | Y          | N        | 移动语义，完美转发         |
  | 常量右值引用   | N          | N        | Y          | Y        | 无实际用途                 |



- 模板实例化和具体化

  默认情况下，模板都是隐式实例化（implicit instantiation），来使用模板生成函数定义。但是也可以显式实例化（explicit instantiation），这意味这可以直接命令编译器创建特定的实例。显式实例化如下：

  ```c++
  template void swap<int>(int, int); //explicit instantiation
  ```

  与显式实例化不同的是，显式具体化使用下面两个等价的声明之一：

  ```c++
  template <> void swap<int>(int &, int &); //explicit specialization
  template <> void swap(int &, int &); //explicit specialization
  ```

  这些声明的意思是“不要使用swap模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义”。试图在同一个文件中使用同一种类型的显式实例和显式具体化将出错。

  还可以通过在程序中使用函数来创建显式实例化，如下：

  ```c++
  template <class T>
  T add(T a, T b) {
  	return a + b;
  }
  ...
  int m = 54;
  double x = 10.2;
  cout << Add<double>(x, m) << endl; //explicit instantiation，m将被强制转换成double类型
  ```



- 有重载函数和函数模板、实例化、具体化时应该选择哪种函数版本执行

  `TODO:`

